gitk() {
    /Applications/GitKraken.app/Contents/MacOS/GitKraken -p $(pwd)
}

# Creates a compressed backup of a folder
backup_folder() {
    if [[ -z "$1" ]]; then
        echo "Usage: backup_folder <folder_path>"
        return 1
    fi

    if [[ ! -d "$1" ]]; then
        echo "Error: Directory not found: $1"
        return 1
    fi

    # Remove trailing slash if present
    local folder=${1%/}
    local timestamp=$(date +"%Y.%m.%d.%H%M%S")
    local backup_name="${timestamp}--${folder}.bak.tar.gz"

    echo "Starting backup process..."
    echo "Source folder: $folder"
    echo "Backup name:   $backup_name"
    echo "Excluding:     */node_modules"

    # Check for node_modules before backup
    if find "$folder" -type d -name "node_modules" | grep -q .; then
        echo "Found node_modules directories that will be excluded:"
        find "$folder" -type d -name "node_modules" -print
    fi

    echo "Creating backup archive..."
    tar --exclude='*/node_modules' -czvf "$backup_name" "$folder"

    if [[ $? -eq 0 ]]; then
        local size=$(du -h "$backup_name" | cut -f1)
        echo "✓ Backup completed successfully"
        echo "Location: $(pwd)/$backup_name"
        echo "Size:     $size"
    else
        echo "✗ Error creating backup"
        return 1
    fi
}

ttd() {
    yt-dlp --verbose -o "[%(uploader)s-%(id)s] $2.%(ext)s" $1
}

webm2mp4() {
    input_file="$1"
    output_file="${input_file%.*}.mp4"
    ffmpeg -i "$input_file" -c:v libx264 -crf 23 -c:a aac -q:a 100 "$output_file"
    echo "Converted $input_file to $output_file"
}

ytd() {
    output=$(yt-dlp --extractor-args youtube:player_client=default,ios -S res,vcodec:vp9 --verbose --get-filename "$1")
    yt-dlp --extractor-args youtube:player_client=default,ios -S res,vcodec:vp9 --verbose "$1"

    if [[ "$output" == *.webm ]]; then
        webm2mp4 "$output"
        rm "$output"
    fi
}

print_env_vars() {
    if [[ -z "$1" ]]; then
        echo "Usage: print_env_vars <file_path>"
        return 1
    fi

    if [[ ! -f "$1" ]]; then
        echo "Error: File not found: $1"
        return 1
    fi

    grep -oE '^[A-Za-z_][A-Za-z0-9_]*=' "$1" | sed 's/=$//' | sort
}

git_summary() {
    local base_ref

    # If a commit hash is provided, use it as the base reference
    if [[ -n "$1" ]]; then
        if git rev-parse --verify "$1" >/dev/null 2>&1; then
            base_ref="$1"
        else
            echo "Error: Invalid commit hash provided: $1"
            return 1
        fi
    else
        # Determine the default branch (main or master) if no commit hash provided
        if git show-ref --quiet refs/heads/main; then
            base_ref="main"
        elif git show-ref --quiet refs/heads/master; then
            base_ref="master"
        else
            echo "Error: Neither 'main' nor 'master' branch found."
            return 1
        fi
    fi

    # Generate log file
    git -P log --oneline ${base_ref}..HEAD > git-log.txt
    echo "Generated git-log.txt"

    # Generate diff file
    git -P diff -U0 ${base_ref}..HEAD > git-diff.txt
    echo "Generated git-diff.txt"

    echo "Git summary completed. Files created: git-log.txt and git-diff.txt"
}

# Creates or updates .env.example by stripping values from source env file
env_example() {
    local source=${1:-.env.local}  # Default to .env.local if no source provided
    local target=${2:-.env.example}  # Default to .env.example if no target provided

    if [[ ! -f $source ]]; then
        echo "Error: Source file '$source' not found"
        return 1
    fi

    # Create backup if target already exists
    if [[ -f $target ]]; then
        cp "$target" "$target.bak"
    fi

    # Strip values and create/update .env.example
    sed 's/=.*$/=/' "$source" > "$target"

    echo "Created $target from $source"
    echo "If you want to preview without values, use: sed 's/=.*$/=/' $source"
}

ask() {
    local ask_dir="$HOME/xo/ask"
    local current_dir=$(pwd)
    
    # Create directories if they don't exist
    mkdir -p "$ask_dir"
    
    # Change to the ask directory
    cd "$ask_dir"
    
    # Start aider session with full options
    aider --env-file ~/.env.aider --dry-run --chat-mode ask
    
    # Return to previous directory
    cd "$current_dir"
}
